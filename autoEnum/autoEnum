#!/bin/bash

# ---------- Constants ----------
RESTORE="\033[0m"
RED="\033[031m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
START="$(date +%s)" # Timing the execution


# ---------- Optional Arguments ----------

# Defaults:
dnsServers=""
do_help=""
nb_checked=0
ldap_checked=0

while getopts "hr:t:d:" flag; do
  case "${flag}" in
    h) do_help="yes";;
    r) cidr="${OPTARG}";;
    t) top="${OPTARG}";;
    d) dnsServers="--dns-servers ${OPTARG}";;
    *) error_msg "Invalid options provided";;
  esac
done
shift $((OPTIND-1))


# ---------- Utility Functions ----------

# Print usage and exit
usage() {
  printf "\n%bUsage: %b%s [OPTIONS] <Single target's IP/Targets file>\n" "${GREEN}" "${RESTORE}" "$(basename "$0")"
  printf "%b\t-h :%b Display this help and exit.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-r :%b Specify a CIDR range to use tools for whole subnets.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-t :%b Run port sweep with nmap and the flag --top-ports=<your input>\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-d :%b Specify custom DNS servers. Default option: %b-n%b.\n" "${YELLOW}" "${RESTORE}" "${YELLOW}" "${RESTORE}"
  printf "%b\nExamples:\n\t%s 192.168.142.93\n\t%s 10.129.121.60 %b-d%b <serv1[,serv2],...>\n\t%s 10.129.121.60 %b-r%b 10.129.121.0/24\n\t%s targets_file.txt %b-r%b 10.10.8.0/24%b" "${GREEN}" "$(basename "$0")" "$(basename "$0")" "${YELLOW}" "${GREEN}" "$(basename "$0")" "${YELLOW}" "${GREEN}" "$(basename "$0")" "${YELLOW}" "${GREEN}" "${RESTORE}"
  exit 1
}

# Print red error messages and call usage
error_msg() {
  printf "%b[-] Error detected: \n[-] %s%b\n" "${RED}" "$1" "${RESTORE}" 1>&2; usage; 
}

# Test whether the host is pingable and set -Pn accordingly
answers_icmp() {
  # If ping is not returned within a second, then ping scan is disabled with -Pn
  ping_test="$(ping -c 1 -W 1 "$1" 2>/dev/null | grep ttl)"
  if [ -z "${ping_test}" ]; then
    printf "%b[-]%b Ping against %b'%s'%b %bnot possible%b, please make sure your target IP address is correct. Assuming host is up, using -Pn flag for the full scan.%b\n" "${RED}" "${YELLOW}" "${RESTORE}" "$IP" "${YELLOW}" "${RED}" "${YELLOW}" "${RESTORE}"
    ping="-Pn"
  else
    ping=""
  fi
}

running_tool() {
  printf "%b[!] Starting %b%s%b and sending it to the background.%b\n" "${YELLOW}" "${BLUE}" "${1}" "${YELLOW}" "${RESTORE}"
}

finished_tool() {
  # First arg tool name, second arg IP address, third arg directory
  printf "%b[+] Done! %b%s%b for '%b%s%b' finished working on the background. Shortcut:\n\tless %s\n%b" "${GREEN}" "${BLUE}" "${1}" "${GREEN}" "${RESTORE}" "${2}" "${YELLOW}" "${3}" "${RESTORE}"
}

print_phase() {
  printf "\n%b%s%b%s%b" "${BLUE}" "[*] ---------- " "${RESTORE}" "Starting Phase " "${YELLOW}"
  phase="${1}"
  case "${phase}" in
  0)
    printf "%s%b%s" "0" "${RESTORE}" ": running initial checks ";;
  1)
    printf "%s%b%s" "1" "${RESTORE}" ": parsing the CIDR range ";;
  2)
    printf "%s%b%s" "2" "${RESTORE}" ": parsing target or list ";;
  3)
    printf "%s%b%s" "3" "${RESTORE}" ": parsing found ports ";;
  4)
    printf "%s%b%s" "4" "${RESTORE}" ": background tools working ";;
  *)
    error_msg "Development error. There are currently 5 phases in the script ";;
  esac
  printf "%b%s%b\n\n" "${BLUE}" "----------" "${RESTORE}"
}

print_hulk() {
  printf "
%b              _____      %b__________                         
%b______ ____  ___  /_______%b__  ____/__________  ________ ___ 
%b_  __ \`/  / / /  __/  __ \\%b_  __/  __  __ \\  / / /_  __ \`__ \\
%b/ /_/ // /_/ // /_ / /_/ /%b  /___  _  / / / /_/ /_  / / / / /
%b\__,_/ \\__,_/ \\__/ \\____/%b/_____/  /_/ /_/\\__,_/ /_/ /_/ /_/ 
%b                    by 0x5ubt13                               \n%b                                            
" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${GREEN}" "${RESTORE}"

}

# ---------- Enumeration Funcions ----------

# Quickly scan all TCP ports and save them to $ports
ports_sweep() {
  # First arg target IP, second arg dir
  if [ -n "$dnsServers" ]; then
    # Nmap ports sweep with --dns-servers
    printf "%b[+]%b -d%b flag detected. Running nmap port sweep with custom DNS servers: %s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${dnsServers}" "${RESTORE}"
    if [ -n "$top" ]; then
        # Nmap ports sweep with --top-ports=<${top}>
        printf "%b[+]%b -t%b flag also detected. Running nmap port sweep with --top-ports=%s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${top}" "${RESTORE}"
        printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
        ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 --top-ports="${top}" "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    else
        printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
        ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    fi
  else
    dnsServers="-n"
    if [ -n "$top" ]; then
      # Nmap ports sweep with --top-ports=<${top}>
      printf "%b[+]%b -t%b flag detected. Running nmap port sweep with --top-ports=%s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${top}" "${RESTORE}"
      printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
      ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 --top-ports="${top}" "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    else
      rustscan_check=$(locate "/bin/rustscan" -l 1)
      if [ -n "$rustscan_check" ]; then
        # Rustscan ports sweep
        printf "%b[+] %bRustscan%b found, proceeding to sweep ports with Rustscan%b" "${GREEN}" "${BLUE}" "${GREEN}" "${RESTORE}"
        printf "\n%b[!] Starting %bRustscan's%b SYN port discovery scan against %b'%s'%b, please bear with...\n" "${YELLOW}" "${BLUE}" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
        ports="$(rustscan -a "$IP" "$dnsServers" --ulimit 5000 -g | cut -d ' ' -f 3 | sed 's/[^[:alnum:],\t]//g')"
      else
        # Nmap ports sweep
        printf "%b[-] Rustscan not installed, using nmap -p- as a default for port sweeping.%b" "${YELLOW}" "${RESTORE}"
        printf "\n${YELLOW}[+] Starting nmap SYN port discovery scan against ${RESTORE}'%s'${YELLOW}...\n" "$1"
        ports=$(nmap --min-rate=2000 -sS -p- -T5 "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
      fi
    fi
  fi
  
  # Check there are ports in the var
  if [ -z "$ports" ]; then
    sweep_result=1
  else
    sweep_result=0 # Needed to check later on to avoid throwing an "illegal number" error
    echo "$ports" > "${2}"open_ports.txt
    printf "%b[+] Done! Found open ports on target.\n\tOpen ports in %b'%s'%b: %b%s\n%b[*] Saved as '%b%sopen_ports.txt%b' in nmap-friendly format.%b\n" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}" "${ports}" "${BLUE}" "${RESTORE}" "${2}" "${BLUE}" "${RESTORE}"
  fi   
}

# Proceed with an aggressive scan
aggressive_scan() {
  # First arg IP, second arg directory
  printf "%b[!] Starting %bmain aggressive nmap scan%b against %b'%s' and sending it to the background\n" "${YELLOW}" "${BLUE}" "${YELLOW}" "${RESTORE}" "${1}"
  printf "%b[!] Running '%bnmap -sVC -v %s --script=vuln -oA %snmap_scan -p%s %s --stats-every 15s &%b.\n\tUse '%btail -f %snmap_tailable_progress.out%b' to see the progress'%b\n" "${YELLOW}" "${RESTORE}" "${ping}" "${2}" "${ports}" "${1}" "${YELLOW}" "${RESTORE}" "${2}" "${YELLOW}" "${RESTORE}"
  printf "%b[+] Saving output to %b%snmap_scan.out %bin all formats.%b\n\n" "${GREEN}" "${RESTORE}" "${2}" "${GREEN}" "${RESTORE}"
  
  nmap "${1}" -v -sVC "$ping" --script=vuln -oA "${2}nmap_scan" -p"$ports" --stats-every 15s >> "${2}"nmap_tailable_progress.out && \
    xsltproc "${2}nmap_scan.xml" -o "${2}nmap_scan.html" && \
    printf "%b[+] Successfully generated HTML report of the Nmap scan, available at '%b%s%b'.%b\n" "${GREEN}" "${RESTORE}" "${2}nmap_scan.nmap" "${GREEN}" "${RESTORE}" && \
    finished_tool "Main aggressive nmap scan" "${1}" "${2}nmap_scan.nmap" &
}

wp_enumeration() {
  # Enumeration for WordPress. First arg IP, second arg Port, third arg dir
  wp_version=$(curl -s -X GET http://"${IP}":"${1}" | grep 'wp-content')
  if [ -n "$wp_version" ]; then
    printf "%b[+]%b WordPress%b found.\n" "${GREEN}" "${YELLOW}" "${RESTORE}" 
    running_tool "WPScan"
    wpscan --url http://"${1}":"${2}" -e p,u >> "${3}"wpscan_port_"${2}".out 2>&1 && \
      finished_tool "WPScan" "${1}" "${3}wpscan.out" & 
  fi
}

# Enumerate a whole CIDR range using specific range tools
cidr_enumeration() {
  # First arg target CIDR, second arg dir
  if [ -n "$cidr" ]; then
    # Create dir for output
    cidr_dir="${2}${cidr}_range_enum/"
    mkdir "${cidr_dir}"
    
    # Run range tools
    printf "%b[+]%b -c%b flag detected. Proceeding to scan CIDR range with dedicated range enumeration tools.\n%b" "${GREEN}" "${YELLOW}" "${GREEN}" "${RESTORE}"
    
    running_tool "nbtscan-unixwiz" 
    nbtscan-unixwiz -f "$cidr" >> "${cidr_dir}"nbtscan-unixwiz.out 2>&1 && \
      finished_tool "nbtscan-unixwiz" "$cidr" "${cidr_dir}nbtscan-unixwiz.out" &
    
    running_tool "Responder-RunFinger"
    responder-RunFinger -i "$cidr" >> "${cidr_dir}"runfinger.out 2>&1 && \
      finished_tool "responder-RunFinger" "$cidr" "${cidr_dir}runfinger.out" &
    
    running_tool "onesixtyone"
    onesixtyone -c /usr/share/legion/wordlists/snmp-default.txt "$cidr" -o "${cidr_dir}"onesixtyone.out -w 100 >> "${cidr_dir}"onesixtyone_tailable.out 2>&1 && \
      finished_tool "onesixtyone" "$cidr" "${cidr_dir}onesixtyone.out" &
  else
    printf "%b[!] CIDR range %bNOT%b detected. Remember you can also pass a range in CIDR notation to use enum tools that scan a wide range with \n\t%bautoenum -r <IP address>/<network mask>%b\n" "${YELLOW}" "${RED}" "${YELLOW}" "${BLUE}" "${RESTORE}" 
  fi
}

# Core functionality of this script: iterate through each port and automate launching tools
ports_iterator() {
  # First arg target IP, second arg dir to save output
  dir="${2}"
  
  # Convert comma-separated string to an array of ports
  IFS=',' read -ra PORTS_ARRAY <<< "$ports" ## TODO: convert Here-Strings to POSIX
  
  # Only look once for the wordlists
  dir_list_medium=$(locate "directory-list-2.3-medium.txt" -l 1) && \
    printf "%b[+] Found directory wordlist for web fuzzers.\n\tUsing '%b%s%b%s'\n" "${GREEN}" "${YELLOW}" "${dir_list_medium}" "${GREEN}" "${RESTORE}"
  darkweb_top1000=$(locate "darkweb2017-top1000.txt" -l 1) && \
    printf "%b[+] Found passwords wordlist for password sprayers.\n\tUsing '%b%s%b%s'\n" "${GREEN}" "${YELLOW}" "${darkweb_top1000}" "${GREEN}" "${RESTORE}" 

  # Iterate over each port in the array
  for port in "${PORTS_ARRAY[@]}"; do ## TODO: convert array to POSIX
    # Use a case statement to perform different actions for each port
    case $port in
    # ---------- SMTP ----------
    25|465|587) 
      # SMTP enumeration. Just run once for now.
      if [ ! -f "${dir}smtp_tailable_nmap_scan.nmap" ]; then
        printf "%b[+] Running SMTP enum tools in port %s%b\n" "${GREEN}" "${port}" "${RESTORE}" 
        nmap -p"$port" --script=smtp-commands,smtp-enum-users,smtp-open-relay "$1" -v -oA snmp-enum >> "${dir}"smtp_tailable_nmap_scan.out 2>&1 && \
          finished_tool "Nmap for SMTP" "${1}" "${dir}snmp-enum.nmap" &
      fi
      ;;
    # ---------- Web ----------
    80)
      # Common Web without TLS 
      printf "%b[+] Running Web enum tools in port 80%b\n" "${GREEN}" "${RESTORE}"

      running_tool "Nikto on port 80"
      nikto -host "${1}" >> "${dir}"nikto_tailable_80.out 2>&1 && \
        finished_tool "Nikto" "${1}" "${dir}nikto_80.out" &
      
      # ffuf killswitch activated after 5 mins of running to save energy and avoid dangling processes consuming CPU
      running_tool "ffuf on port 80"
      ffuf -u http://"${1}":80/FUZZ -w "$dir_list_medium":FUZZ -recursion -recursion-depth 1 -e .php,.asp,.aspx -t 20 -v -maxtime 300 -maxtime-job 300 >> "${dir}"ffuf_80_tailable.out 2>&1 && \
        finished_tool "ffuf" "${1}" "${dir}ffuf_tailable_80.out" &
      
      wp_enumeration "${1}" "80" "${dir}"
      ;;
    443)
      # Common Web 
      printf "%b[+] Running Web enum tools in port 443%b\n" "${GREEN}" "${RESTORE}"

      running_tool "Nikto"
      nikto -host "${1}" >> "${dir}"nikto_tailable_443.out 2>&1 && \
        finished_tool "Nikto on port 443" "${1}" "${dir}nikto_tailable_443.out" &

      # ffuf killswitch activated after 5 mins of running to save energy and avoid dangling processes consuming CPU
      running_tool "ffuf on port 443"
      ffuf -u https://"${1}":443/FUZZ -w "$dir_list_medium":FUZZ -recursion -recursion-depth 1 -e .php,.asp,.aspx -t 20 -v -maxtime 300 -maxtime-job 300 >> "${dir}"ffuf_443_tailable.out 2>&1 && \
        finished_tool "ffuf on port 443" "${1}" "${dir}ffuf_tailable_443.out" &
      
      wp_enumeration "${1}" "443" "${dir}"
      ;;
    8080) 
      # Try enumerate Services on 8080 
      wp_enumeration "${1}" "8080" "${dir}" 

      tomcat_version=$(curl -s -X GET http://"${IP}":8080/docs/ | grep -i 'Tomcat')
      if [ -n "$tomcat_version" ]; then
        printf "%b[+] Web service Tomcat detected. Running Tomcat enum tools%b\n" "${GREEN}" "${RESTORE}"
  
        running_tool "gobuster"
        gobuster -z -q dir -e -u "${1}":8080 -w "$dir_list_medium" >> "${dir}"gobuster_tomcat.out 2>&1 && \
          finished_tool "gobuster on port 8080" "${1}" "${dir}gobuster_tomcat.out" &
        
        running_tool "hydra"
        hydra -L users.txt -P "$darkweb_top1000" -f "${1}" http-get /manager/html >> "${dir}"hydra_tailable.out 2>&1 && \
          finished_tool "Hydra" "${1}" "${dir}hydra_tailable.out" &
      fi
      ;;
    # ---------- RPC ----------
    111)
      # Enumerate RPC
      printf "%b[+] RPC service detected. Running RPC nmap enum scripts.%b\n" "${GREEN}" "${RESTORE}"
      nmap -p 111 --script "nfs*" "${1}" -oA "${dir}"rpc_nmap_scan >> rpc_tailable_nmap_scan 2>&1 && \
        finished_tool "Nmap against RPC on port 111" "${1}" "${dir}rpc_nmap_scan.nmap" &
      
      running_tool "RPCclient"
      rpcclient -U "" "${1}" >> "${dir}"rpcclient_anon.out 2>&1 && \
        finished_tool "RPCclient" "${1}" "${dir}rpcclient_anon.out" &
      ;;
    # ---------- NetBios / SMB ----------
    139|445)
      # Enumerate NB/SMB. Run only once
      if [ "$nb_checked" -eq 0 ]; then
        nb_checked=1
        printf "%b[+] NetBIOS/SMB detected. Running SMB enum tools%b\n" "${GREEN}" "${RESTORE}"
        
        running_tool "SMBMap"
        smbmap -H "${1}" >> "${dir}"smbmap_anon.out 2>&1 && \
          finished_tool "SMBMap" "${1}" "${dir}smbmap_anon.out" &
  
        running_tool "NBLookup"
        nmblookup -A "${1}" >> "$dir"nmblookup.out 2>&1 && \
          finished_tool "NMBLookup" "${1}" "${dir}nmblookup.out" &
    
        running_tool "enum4linux"
        enum4linux -u '' -p '' "${1}" >> "$dir"enum4linux_anon.out 2>&1 && \
          finished_tool "enum4linux" "${1}" "${dir}enum4linux_anon.out" &
      fi
      ;;
    # ---------- LDAP ----------
    389|636|3268|3269)
      # Run only once
      if [ "$ldap_checked" -eq 0 ]; then
        ldap_checked=1
        printf "%b[+] Running LDAP enum tools in port %s%b\n" "${GREEN}" "${port}" "${RESTORE}" 
        
        running_tool "ldapsearch (null credentials attack)"
        ldapsearch -x -H ldap://"${1}" -D '' -w '' -b "DC=<1_SUBDOMAIN>,DC=<TLD>" >> "${dir}"ldapsearch.out 2>&1 && \
          finished_tool "ldapsearch" "${1}" "${dir}ldapsearch.out" &
        
        running_tool "Nmap for LDAP"
        nmap -p"$port" -n -sV --script "ldap* and not brute" "${1}" -v -oA ldap_enum >> "${dir}"ldap_tailable_nmap_scan.out 2>&1 && \
          finished_tool "Nmap for LDAP" "${1}" "${dir}ldap_enum.nmap" &
      fi
      ;;
    # ---------- SSH ----------
    22)
      nmap -p22 "${1}" --script "ssh*" -oN "${dir}ssh_enum" -v >> "${dir}"ssh_tailable_nmap_scan.out 2>&1 && \
        finished_tool "Nmap scripts for SSH" "${1}" "${dir}ssh_enum.nmap" &
      ;;
    21)
      nmap -p21 "${1}" --script "ftp-*" -oN "${dir}ftp_enum" -v >> "${dir}"ftp_tailable_nmap_scan.out 2>&1 && \
        finished_tool "Nmap scripts for FTP" "${1}" "${dir}ftp_enum.nmap" &
      ;;
    *)
      printf "%b[-]%b Port %b%s%b detected, but functionality to enumerate it has not been implemented yet.\n" "${RED}" "${RESTORE}" "${YELLOW}" "$port" "${RESTORE}"
      ;;
    esac
  done
  printf "%b[+] Done! All well-known ports included in the script successfully parsed for %b%s%b.\n%b" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}"
}


# ---------- Let the fun begin! MAIN Function ----------

main() {
  print_phase 1
  # Perform CIDR enumeration first, check if CIDR argument was passed
  cidr_enumeration "${DIR}"
  
  print_phase 2
  # Check whether input is a single or multiple target and loop accordingly
  if [[ ! -f "$IP" ]]; then 
    # ---------- Single target ----------
    dir="${DIR}${IP}/"

    # Colouring red to catch mkdir's File exists error
    printf "%b" "${RED}"; mkdir "${dir}"; printf "%b" "${RESTORE}"
    printf "%b[+] Using '%b%s%b' as single target IP and '%b%s%b' for all the tools output%b\n" "${GREEN}" "${RESTORE}" "${IP}" "${GREEN}" "${RESTORE}" "${dir}" "${GREEN}" "${RESTORE}"

    # Checking whether the target is reachable via ping
    answers_icmp "${IP}"

    # Do port discovery scan
    ports_sweep "${IP}" "${dir}"
    
    # Abort tests if no ports were found open
    if [ "$sweep_result" -eq 1 ]; then 
      printf "%b[-] No open ports were found in %s, aborting all scans\n%b" "${RED}" "${IP}" "${RESTORE}"
      exit 1
    fi

    print_phase 3
    # If still alive, proceed with nmap scan and ports iterator
    aggressive_scan "${IP}" "${dir}"

    # Iterate over each port in the array
    ports_iterator "${IP}" "${dir}" ## TODO: convert ports_iterator to POSIX
  else # ---------- Multi-target: ----------
    printf "%b[+] Using %b'%s'%b as targets file\n" "${GREEN}" "${RESTORE}" "${IP}" "${GREEN}" 
    printf "[+] Successfully identified %b'%s'%b targets in the file\n" "${RESTORE}" "${list_total_lines}" "${GREEN}"

    # loop through the targets and assign vars accordingly
    line=1
    print_phase 3
    while [ "$line" -le "$list_total_lines" ]; do
      target=$(sed "${line}q;d" "$IP" 2>/dev/null)
      # target_number="_target_${line}"
      dir="$(pwd)/nmap/${target}/"
  
      # Colouring red to catch mkdir's File exists error
      printf "%b" "${RED}"; mkdir "${dir}"; printf "%b" "${RESTORE}"
      
      # More info to console
      printf "%b[+] Attacking target '%b%s%b/%b%s%b': '%b%s%b'. " "${GREEN}" "${RESTORE}" "${line}" "${GREEN}" "${RESTORE}" "$list_total_lines" "${GREEN}" "${RESTORE}" "$target" "${GREEN}"
      printf "%b[+] Using '%b%s%b' for all this target's tools output%b\n" "${GREEN}" "${RESTORE}" "${dir}" "${GREEN}" "${RESTORE}" 
  
      # TCP Scans
      # Checking whether the target is reachable via ping
      answers_icmp "$target"
  
      # Do port discovery scan
      ports_sweep "$target"
      
      # Abort tests if no ports were found open
      if [ "$sweep_result" -eq 1 ]; then 
        printf "%b[-] No open ports were found in %s, aborting all scans for this target\n%b" "${RED}" "${target}" "${RESTORE}"
      else
        # Proceed with nmap scan and ports iterator
        aggressive_scan "$target"

        # Iterate over each port in the array
        ports_iterator "$target" ## TODO: convert ports_iterator to POSIX
      fi

      # Loop counter
      line=$(( line + 1 ))
    done
  fi
}


# ---------- Script checks, ensuring everything is ready to run ----------

# Check 0: Launch fancy (Bruce) Banner! 
print_hulk
# Ba-dum-tss!

print_phase 0

# Check 1: help flag passed?
if [ -n "$do_help" ]; then
    printf "%b[*] Help flag detected. Aborting other cheks and printing usage.\n%b" "${BLUE}" "${RESTORE}"
    usage
fi

# Check 2: Ensure there is a target
if [[ -n "$1" ]]; then
  IP="$1"
else
  error_msg "You must provide an IP address or targets file to start the attack"
fi

# Check 3: Determine whether it is a single target or multi-target
if [[ ! -f "$IP" ]]; then # Single target
  # Ensure $IP is either an IP or a URL
  if ! expr "${IP}" : "\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)" >/dev/null && \
     ! expr "${IP}" : "\(\([[:alnum:]-]\{1,63\}\.\)*[[:alpha:]]\{2,6\}\)" >/dev/null; then
      error_msg "Invalid IP or URL!"
  fi
else
  # Multi-target, check how many targets are there
  list_total_lines=$(wc -l "$IP" | awk '{ print $1 }')
fi

# Check 4: Ensure base output directory is correctly set and exists
## TODO: create option to set custom directory if launched autonomously outside Docker
if test "$(pwd)" = "/"; then
  DIR="/autoEnum_output/"
else
  DIR="$(pwd)/autoEnum_output/"
fi

if [[ ! -d "${DIR}" ]]; then
  mkdir "${DIR}"
fi

# Check 5: locate exists in the system
updatedb_check=$(which updatedb)
if [ -z "$updatedb_check" ]; then
  error_msg "AutoEnum needs \"locate\" to be installed. Please see or run \"install_requisites.sh\""
fi

printf "%b[+] Using '%b%s%b' as base directory where to save the output files%b\n" "${GREEN}" "${RESTORE}" "${DIR}" "${GREEN}" "${RESTORE}"


# ---------- Preliminary checks completed. Starting engines calling main function ----------

# Let there be (~l~i~g~h~t~) enumeration.
main

# ---------- Finish script and wait for tools to finish on the background ----------

# Finished. Getting timing score
print_phase 4
END="$(date +%s)"
runtime="$((END - START))"
printf "%b[*] All done! It only took '%b%s seconds%b' to run autoEnum based on your settings!! Please allow your tools some time to finish. \n\tIf you want to see what they are doing, run %b'tail -f %s/<IP Address>/<output file>'%b\n" "${BLUE}" "${GREEN}" "$runtime" "${BLUE}" "${YELLOW}" "${DIR}" "${RESTORE}"
printf "\n\n%b[*] %s" "${BLUE}" "This tool is still in its early days. Do you have any feedback? Please feel free to reach out: https://github.com/0x5ubt13"