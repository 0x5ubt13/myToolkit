#!/bin/bash

# ---------- Constants ----------
RESTORE="\033[0m"
RED="\033[031m"
GREEN="\033[32m"
YELLOW="\033[33m"
START="$(date +%s)" # Timing the execution


# ---------- Optional Arguments ----------

# Defaults:
dnsServers=""
do_help=""
nb_checked=0

while getopts "hr:t:d:" flag; do
  case "${flag}" in
    h) do_help="yes";;
    r) cidr="${OPTARG}";;
    t) top="${OPTARG}";;
    d) dnsServers="--dns-servers ${OPTARG}";;
    *) error_msg "Invalid options provided";;
  esac
done
shift $((OPTIND-1))


# ---------- Utility Functions ----------

# Print usage and exit
usage() {
  printf "\n%bUsage: %b%s [OPTIONS] <Single target's IP/Targets file>\n" "${GREEN}" "${RESTORE}" "$(basename "$0")"
  printf "%b\t-h :%b Display this help and exit.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-r :%b Specify a CIDR range to use tools for whole subnets.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-t :%b Run port sweep with nmap and the flag --top-ports=<your input>\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-d :%b Specify custom DNS servers. Default option: ${YELLOW}-n${RESTORE}.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\nExamples: \n\t%s 192.168.142.93\n\t%s 10.129.121.60 ${YELLOW}-d${GREEN} <serv1[,serv2],...>\n\t%s 10.129.121.60 ${YELLOW}-r${GREEN} 10.129.121.0/24\n\t%s targets_file.txt ${YELLOW}-r${GREEN} 10.10.8.0/24" "${GREEN}" "$(basename "$0")" "$(basename "$0")" "$(basename "$0")" "$(basename "$0")"
  exit 1
}

# Print red error messages and call usage
error_msg() {
  printf "%b[-] Error:%b %s\n" "${RED}" "$1" "${RESTORE}" 1>&2; usage; 
}

# Test whether the host is pingable and set -Pn accordingly
answers_icmp() {
  # If ping is not returned within a second, then ping scan is disabled with -Pn
  ping_test="$(ping -c 1 -W 1 "$1" 2>/dev/null | grep ttl)"
  if [ -z "${ping_test}" ]; then
    printf "%b[-]%b Ping against %b'%s'%b %bnot possible%b, please make sure your target IP address is correct. Assuming host is up, using -Pn flag for the full scan.%b\n" "${RED}" "${YELLOW}" "${RESTORE}" "$IP" "${YELLOW}" "${RED}" "${YELLOW}" "${RESTORE}"
    ping="-Pn"
  else
    ping=""
  fi
}

running_tool() {
  printf "%b[!] Starting %s and sending it to the background.%b\n" "${YELLOW}" "${1}" "${RESTORE}"
}

finished_tool() {
  # First arg tool name, second arg IP address, third arg directory
  printf "%b[+] Done! %b%s%b for %b%s%b finished working on the background: cat %s\n%b" "${GREEN}" "${YELLOW}" "${1}" "${GREEN}" "${RESTORE}" "${2}" "${GREEN}" "${3}" "${RESTORE}"
}

print_hulk() {
  printf "
              _____      __________                         
______ ____  ___  /_________  ____/__________  ________ ___ 
_  __ \`/  / / /  __/  __ \\_  __/  __  __ \\  / / /_  __ \`__ \\
/ /_/ // /_/ // /_ / /_/ /  /___  _  / / / /_/ /_  / / / / /
\__,_/ \\__,_/ \\__/ \\____//_____/  /_/ /_/\\__,_/ /_/ /_/ /_/ 
                    by 0x5ubt13                               \n                                            
"                                                

}

# ---------- Enumeration Funcions ----------

# Quickly scan all TCP ports and save them to $ports
ports_sweep() {
  # First arg target IP, second arg dir
  if [ -n "$dnsServers" ]; then
    # Nmap ports sweep with --dns-servers
    printf "%b[+]%b -d%b flag detected. Running nmap port sweep with custom DNS servers: %s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${dnsServers}" "${RESTORE}"
    if [ -n "$top" ]; then
        # Nmap ports sweep with --top-ports=<${top}>
        printf "%b[+]%b -t%b flag also detected. Running nmap port sweep with --top-ports=%s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${top}" "${RESTORE}"
        printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
        ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 --top-ports="${top}" "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    else
        printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
        ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    fi
  else
    dnsServers="-n"
    if [ -n "$top" ]; then
      # Nmap ports sweep with --top-ports=<${top}>
      printf "%b[+]%b -t%b flag detected. Running nmap port sweep with --top-ports=%s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${top}" "${RESTORE}"
      printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
      ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 --top-ports="${top}" "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    else
      rustscan_check=$(locate "/bin/rustscan" -l 1)
      if [ -n "$rustscan_check" ]; then
        # Rustscan ports sweep
        printf "%b[+] Rustscan installed, using Rustscan%b" "${GREEN}" "${RESTORE}"
        printf "\n%b[+] Starting Rustscan SYN port discovery scan against %b'%s'%b, please bear with...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
        ports="$(rustscan -a "$IP" "$dnsServers" --ulimit 5000 -g | cut -d ' ' -f 3 | sed 's/[^[:alnum:],\t]//g')"
      else
        # Nmap ports sweep
        printf "%b[-] Rustscan not installed, using nmap -p- as a default for port sweeping.%b" "${YELLOW}" "${RESTORE}"
        printf "\n${YELLOW}[+] Starting nmap SYN port discovery scan against ${RESTORE}'%s'${YELLOW}...\n" "$1"
        ports=$(nmap --min-rate=2000 -sS -p- -T5 "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
      fi
    fi
  fi
  
  # Check there are ports in the var
  if [ -z "$ports" ]; then
    sweep_result=1
  else
    sweep_result=0 # Needed to check later on to avoid throwing an "illegal number" error
    echo "$ports" > "${2}"open_ports.txt
    printf "\n%b[+] Done! Open ports in %b'%s'%b: %b%s\n%b[+] Saved as %b%sopen_ports.txt%b in nmap-friendly format.%b\n" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}" "${ports}" "${GREEN}" "${RESTORE}" "${2}" "${GREEN}" "${RESTORE}"
  fi   
}

# Proceed with an aggressive scan
aggressive_scan() {
  # First arg IP, second arg directory
  printf "%b[+] Starting aggressive scan against %b'%s'\n" "${YELLOW}" "${RESTORE}" "${1}"
  printf "%b[!] Running '%bnmap -sVC %s --script=vuln -oA %snmap_scan -p%s %s &%b. Use '%btail -f %snmap_tailable_progress.out%b' to see the progress'%b\n" "${YELLOW}" "${RESTORE}" "${ping}" "${2}" "${ports}" "${YELLOW}" "${1}" "${RESTORE}" "${2}" "${YELLOW}" "${RESTORE}"
  printf "%b[+] Saving output to %b${2}nmap_scan.out %bin all formats.%b\n\n" "${GREEN}" "${RESTORE}" "${GREEN}" "${RESTORE}"
  
  nmap "${1}" -vvv -sVC "$ping" --script=vuln -oA "${2}nmap_scan" -p"$ports" >> "${2}"nmap_tailable_progress.out && xsltproc "${2}nmap_scan.xml" && finished_tool "Main aggressive nmap scan for IP ${1}" "${1}" "${2}nmap_scan.nmap" &  
}

wp_enumeration() {
  # Enumeration for WordPress. First arg IP, second arg Port, third arg dir
  wp_version=$(curl -s -X GET http://"${IP}":"${1}" | grep 'wp-content')
  if [ -n "$wp_version" ]; then
    printf "%b[+]%b WordPress%b found.\n" "${GREEN}" "${YELLOW}" "${RESTORE}" 
    running_tool "WPScan"
    wpscan --url http://"${1}":"${2}" -e p,u >> "${3}"wpscan_port_"${2}".out 2>&1 && \
      finished_tool "WPScan" "${1}" "${3}wpscan.out" & 
  fi
}

# Enumerate a whole CIDR range using specific range tools
cidr_enumeration() {
  # First arg target CIDR, second arg dir
  if [ -n "$cidr" ]; then
    # Create dir for output
    cidr_dir="${2}${cidr}_range_enum/"
    mkdir "${cidr_dir}"
    
    # Run range tools
    printf "%b[+]%b -c%b flag detected. Proceeding to scan CIDR range with dedicated range enumeration tools.\n%b" "${GREEN}" "${YELLOW}" "${GREEN}" "${RESTORE}"
    
    running_tool "nbtscan-unixwiz" 
    nbtscan-unixwiz -f "$cidr" >> "${cidr_dir}"nbtscan-unixwiz.out 2>&1 && \
      finished_tool "nbtscan-unixwiz" "$cidr" "${cidr_dir}nbtscan-unixwiz.out" &
    
    running_tool "Responder-RunFinger"
    responder-RunFinger -i "$cidr" >> "${cidr_dir}"runfinger.out 2>&1 && \
      finished_tool "responder-RunFinger" "$cidr" "${cidr_dir}runfinger.out" &
    
    running_tool "onesixtyone"
    onesixtyone -c /usr/share/legion/wordlists/snmp-default.txt "$cidr" -o "${cidr_dir}"onesixtyone.out -w 100 >> "${cidr_dir}"onesixtyone_tailable.out 2>&1 && \
      finished_tool "onesixtyone" "$cidr" "${cidr_dir}onesixtyone.out" &
  else
    printf "%b[!] CIDR range %bNOT%b detected. Remember you can also pass a range in CIDR notation to use enum tools that scan a wide range with %b-r <IP address>/<network mask>%b\n" "${YELLOW}" "${RED}" "${YELLOW}" "${GREEN}" "${RESTORE}" 
  fi
}

# Core functionality of this script: iterate through each port and automate launching tools
ports_iterator() {
  # First arg target IP, second arg dir to save output
  dir="${2}"
  
  # Convert comma-separated string to an array of ports
  IFS=',' read -ra PORTS_ARRAY <<< "$ports" ## TODO: convert Here-Strings to POSIX
  
  # Only look once for the wordlists
  dir_list_medium=$(locate "directory-list-2.3-medium.txt" -l 1) && \
    printf "%b[+]%b Found directory wordlist for web fuzzers. Using %b%s%b\n" "${GREEN}" "${RESTORE}" "${YELLOW}" "${dir_list_medium}" "${RESTORE}"
  darkweb_top1000=$(locate "darkweb2017-top1000.txt" -l 1) && \
    printf "%b[+]%b Found passwords wordlist for password sprayers. Using %b%s%b\n" "${GREEN}" "${RESTORE}" "${YELLOW}" "${dir_list_medium}" "${RESTORE}" 

  # Iterate over each port in the array
  for port in "${PORTS_ARRAY[@]}"; do ## TODO: convert array to POSIX
    # Use a case statement to perform different actions for each port
    case $port in
    25|465|587)
      # SMTP enumeration. Just run once for now.
      if [ ! -f "${dir}smtp_tailable_nmap_scan.nmap" ]; then
        printf "%b[+] Running SMTP enum tools in port %s%b\n" "${GREEN}" "${port}" "${RESTORE}" 
        nmap -p"$port" --script=smtp-commands,smtp-enum-users,smtp-open-relay "$1" -v -oA snmp-enum >> "${dir}"smtp_tailable_nmap_scan.out 2>&1 && \
          finished_tool "Nmap for SMTP" "${1}" "${dir}snmp-enum.nmap" &
      fi
      ;;
    80)
      # Common Web without TLS 
      printf "%b[+] Running Web enum tools in port 80%b\n" "${GREEN}" "${RESTORE}"

      running_tool "Nikto on port 80"
      nikto -host "${1}" >> "${dir}"nikto_tailable_80.out 2>&1 && \
        finished_tool "Nikto" "${1}" "${dir}nikto_80.out" &

      running_tool "ffuf on port 80"
      ffuf -u http://"${1}"/FUZZ -w "$dir_list_medium":FUZZ -recursion -recursion-depth 1 -e .php,.asp,.aspx -t 20 -v >> "${dir}"ffuf_80_tailable.out 2>&1 && \
        finished_tool "ffuf" "${1}" "${dir}ffuf_tailable_80.out" &
      
      wp_enumeration "${1}" "80" "${dir}"
      ;;
    443)
      # Common Web 
      printf "%b[+] Running Web enum tools in port 443%b\n" "${GREEN}" "${RESTORE}"

      running_tool "Nikto"
      nikto -host "${1}" >> "${dir}"nikto_tailable_443.out 2>&1 && \
        finished_tool "Nikto on port 443" "${1}" "${dir}nikto_tailable_443.out" &

      running_tool "ffuf on port 443"
      ffuf -u https://"${1}"/FUZZ -w "$dir_list_medium":FUZZ -recursion -recursion-depth 1 -e .php,.asp,.aspx -t 20 -v >> "${dir}"ffuf_443_tailable.out 2>&1 && \
        finished_tool "ffuf on port 443" "${1}" "${dir}ffuf_tailable_443.out" &
      
      wp_enumeration "${1}" "443" "${dir}"
      ;;
    8080) 
      # Try enumerate Services on 8080 
      wp_enumeration "${1}" "8080" "${dir}" 

      tomcat_version=$(curl -s -X GET http://"${IP}":8080/docs/ | grep -i 'Tomcat')
      if [ -n "$tomcat_version" ]; then
        printf "%b[+] Web service Tomcat detected. Running Tomcat enum tools%b\n" "${GREEN}" "${RESTORE}"
  
        running_tool "gobuster"
        gobuster -z -q dir -e -u "${1}":8080 -w "$dir_list_medium" >> "${dir}"gobuster_tomcat.out 2>&1 && finished_tool "gobuster on port 8080" "${1}" "${dir}gobuster_tomcat.out" &
        
        running_tool "hydra"
        hydra -L users.txt -P "$darkweb_top1000" -f "${1}" http-get /manager/html >> "${dir}"hydra_tailable.out 2>&1 && finished_tool "Hydra" "${1}" "${dir}hydra_tailable.out" &
      fi
      ;;
    111)
      # Enumerate RPC
      printf "%b[+] RPC service detected. Running RPC nmap enum scripts.%b\n" "${GREEN}" "${RESTORE}"
      nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount "${1}" -oA "${dir}"rpc_nmap_scan >> rpc_tailable_nmap_scan 2>&1 && \
        finished_tool "Nmap against RPC on port 111" "${1}" "${dir}rpc_nmap_scan.nmap" &
      
      running_tool "rpcclient"
      rpcclient -U "" "${1}" >> "${dir}"rpcclient_anon.out 2>&1 && \
        finished_tool "rpcclient" "${1}" "${dir}rpcclient_anon.out" &
      ;;
    139|445)
      # Enumerate NB/SMB. Run only once
      if [ "$nb_checked" -eq 0 ]; then
        nb_checked=1
        printf "%b[+] NetBIOS/SMB detected. Running SMB enum tools%b\n" "${GREEN}" "${RESTORE}"
        
        running_tool "SMBMap"
        smbmap -H "${1}" >> "${dir}"smbmap_anon.out 2>&1 && \
          finished_tool "SMBMap" "${1}" "${dir}smbmap_anon.out" &
  
        running_tool "NBLookup"
        nmblookup -A "${1}" >> "$dir"nmblookup.out 2>&1 && \
          finished_tool "NMBLookup" "${1}" "${dir}nmblookup.out" &
    
        running_tool "enum4linux"
        enum4linux -u '' -p '' "${1}" >> "$dir"enum4linux_anon.out 2>&1 && \
          finished_tool "enum4linux" "${1}" "${dir}enum4linux_anon.out" &
      fi
      ;;
    *)
      printf "%b[-]%b Port %b%s%b detected, but functionality to enumerate it has not been implemented yet.\n" "${RED}" "${RESTORE}" "${YELLOW}" "$port" "${RESTORE}"
      ;;
    esac
  done
  printf "%b[+] Done! All well-known ports included in the script successfully parsed for %b%s%b. Enjoy!\n%b" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}"
}


# ---------- Let the fun begin! MAIN Function ----------

main() {
  # Perform CIDR enumeration first, check if CIDR argument was passed
  cidr_enumeration "${DIR}"
  
  # Check whether input is a single or multiple target and loop accordingly
  if [ ! -f "$IP" ]; then 
    # ---------- Single target ----------
    dir="${DIR}${IP}/"

    # Colouring red to catch mkdir's File exists error
    printf "%b" "${RED}" 
    mkdir "${dir}"
    printf "%b" "${RESTORE}"

    # Checking whether the target is reachable via ping
    answers_icmp "${IP}"

    # Do port discovery scan
    ports_sweep "${IP}" "${dir}"
    
    # Abort tests if no ports were found open
    if [ "$sweep_result" -eq 1 ]; then 
      printf "%b[-] No open ports were found in %s, aborting all scans\n%b" "${RED}" "${IP}" "${RESTORE}"
      exit 1
    fi

    # If still alive, proceed with nmap scan and ports iterator
    aggressive_scan "${IP}" "${dir}"

    # Iterate over each port in the array
    ports_iterator "${IP}" "${dir}" ## TODO: convert ports_iterator to POSIX
      
  else
    # ---------- Multi-target: ----------
    # loop through the targets and assign vars accordingly
    line=1
    while [ "$line" -le "$list_total_lines" ]; do
      target=$(sed "${line}q;d" "$IP" 2>/dev/null)
      # target_number="_target_${line}"
      dir="$(pwd)/nmap/${target}/"
  
      # colouring red to catch mkdir's File exists error
      printf "%b" "${RED}" 
      mkdir "${dir}"
      printf "%b" "${RESTORE}"
      
      # More info to console
      printf "%b[+] Attacking target '%b%s%b/%b%s%b': '%b%s%b'. " "${GREEN}" "${RESTORE}" "${line}" "${GREEN}" "${RESTORE}" "$list_total_lines" "${GREEN}" "${RESTORE}" "$target" "${GREEN}"
      printf "Saving all output of this target to %b%s\n" "${RESTORE}" "${dir}"
  
      # TCP Scans
      # Checking whether the target is reachable via ping
      answers_icmp "$target"
  
      # Do port discovery scan
      ports_sweep "$target"
      
      # Abort tests if no ports were found open
      if [ "$sweep_result" -eq 1 ]; then 
        printf "%b[-] No open ports were found in %s, aborting all scans for this target\n%b" "${RED}" "${target}" "${RESTORE}"
      else
        # Proceed with nmap scan and ports iterator
        aggressive_scan "$target"

        # Iterate over each port in the array
        ports_iterator "$target" ## TODO: convert ports_iterator to POSIX
      fi

      # Loop counter
      line=$(( line + 1 ))
    done
  fi
}


# ---------- Script checks, ensuring everything is ready to run ----------

# Check 0: Launch fancy (Bruce) Banner! 
print_hulk
# Ba-dum-tss!

# Check 1: help flag passed?
if [ -n "$do_help" ]; then
    usage
fi

# Check 2: Ensure there is a target
if [[ -n "$1" ]]; then
  IP="$1"
else
  error_msg "You must provide an IP address or targets file to start the attack"
fi

# Check 3: Determine whether it is a single target or multi-target
if [[ ! -f "$IP" ]]; then # Single target
  # Ensure $IP is either an IP or a URL
  if ! expr "${IP}" : "\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)" >/dev/null && \
     ! expr "${IP}" : "\(\([[:alnum:]-]\{1,63\}\.\)*[[:alpha:]]\{2,6\}\)" >/dev/null; then
      error_msg "Invalid IP or URL!"
  fi
else
  # Multi-target, check how many targets are there
  list_total_lines=$(wc -l "$IP" | awk '{ print $1 }')
fi

# Check 4: Ensure base output directory is correctly set and exists
## TODO: create option to set custom directory if launched autonomously outside Docker
if test "$(pwd)" = "/"; then
  DIR="/autoEnum_output/"
else
  DIR="$(pwd)/autoEnum_output/"
fi

if [[ ! -d "${DIR}" ]]; then
  mkdir "${DIR}"
fi

# Check 5: locate exists in the system
updatedb_check=$(which updatedb)
if [ -z "$updatedb_check" ]; then
  error_msg "AutoEnum needs \"locate\" to be installed. Please see or run \"install_requisites.sh\""
fi


# ---------- Preliminary checks completed. Starting engines calling main function ----------

# Single target
if [[ ! -f "$IP" ]]; then   
  printf "\n%b[+] Using %b'%s'%b as target\n" "${GREEN}" "${RESTORE}" "${IP}" "${GREEN}"
# Multiple targets
else 
  printf "%b[+] Using %b'%s'%b as targets file\n" "${GREEN}" "${RESTORE}" "${IP}" "${GREEN}" 
  printf "[+] Successfully identified %b'%s'%b targets in the file\n" "${RESTORE}" "${list_total_lines}" "${GREEN}"
fi

printf "[+] Using '%b%s%b' as base directory where to put the output files\n" "${RESTORE}" "${DIR}" "${GREEN}"

# Let there be (~l~i~g~h~t~) enumeration.
main

# Finished. Getting timing score
END="$(date +%s)"
runtime="$((END - START))"
printf "\n%b[+] All done! It took %s seconds to run the autoEnum based on your settings. Please allow your tools some time to finish. If you want to see what they are doing, run %b'tail -f ./autoEnum_output/<IP Address>/<output file>'%b\n" "${GREEN}" "$runtime" "${YELLOW}" "${RESTORE}"
printf "%b[+] Your files will be available at ${RESTORE}'%s'\n" "${GREEN}" "${DIR}"