#!/bin/bash

# ---------- Constants ----------
RESTORE="\033[0m"
RED="\033[031m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
START="$(date +%s)" # Timing the execution


# ---------- Optional Arguments ----------

# Defaults:
dnsServers=""
do_help=""
verbose=1
slower=0
again=0

while getopts "ad:hp:qr:st:" flag; do
  case "${flag}" in
    a) again=1;;
    d) dnsServers="--dns-servers ${OPTARG}";;
    t) ip="${OPTARG}";;
    h) do_help="yes";;
    q) verbose=0;;
    r) cidr="${OPTARG}";;
    s) slower=1;;
    p) top="${OPTARG}";;
    *) error_msg "Invalid options provided";;
  esac
done
shift $((OPTIND-1))


# ---------- Utility Functions ----------

# Print usage and exit
usage() {
  printf "\n%bUsage: %b%s [OPTIONS] -t <Single target's IP/Targets file>\n" "${GREEN}" "${RESTORE}" "$(basename "$0")"
  printf "%b\t-a:%b Again     - Repeat the scan and compare with initial ports discovered.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-d:%b DNS       - Specify custom DNS servers. Default option: %b-n%b.\n" "${YELLOW}" "${RESTORE}" "${YELLOW}" "${RESTORE}"
  printf "%b\t-h:%b Help      - Display this help and exit.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-p:%b top Ports - Run port sweep with nmap and the flag %b--top-ports=%b<your input>\n" "${YELLOW}" "${RESTORE}" "${YELLOW}" "${RESTORE}"
  printf "%b\t-q:%b Quiet     - Don't print the cool banner and decrease overall verbosity.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-r:%b Range     - Specify a CIDR range to use tools for whole subnets.\n" "${YELLOW}" "${RESTORE}" 
  printf "%b\t-s:%b Slower    - Don't use Rustscan for the initial port sweep.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\t-t:%b Target    - Specify target single IP / List of IPs file.\n" "${YELLOW}" "${RESTORE}"
  printf "%b\nExamples:\n\t%s %b-t%b 192.168.142.93\n\t%s %b-qa -t%b 192.168.142.93\n\t%s %b-t%b 10.129.121.60 %b-d%b <serv1[,serv2],...>\n\t%s %b-t%b 10.129.121.60 %b-r%b 10.129.121.0/24\n\t%s %b-t%b targets_file.txt %b-r%b 10.10.8.0/24%b" "${GREEN}" "$(basename "$0")" "${YELLOW}" "${GREEN}" "$(basename "$0")" "${YELLOW}" "${GREEN}" "$(basename "$0")" "${YELLOW}" "${GREEN}" "${YELLOW}" "${GREEN}" "$(basename "$0")" "${YELLOW}" "${GREEN}" "${YELLOW}" "${GREEN}" "$(basename "$0")" "${YELLOW}" "${GREEN}" "${YELLOW}" "${GREEN}" "${RESTORE}"
  exit 1
}

# Make new directory for the newly enumerated protocol to keep things tidy
custom_mkdir() {
  # Check first dir doesn't exist
  if [ ! -d "${1}" ]; then
    mkdir "${1}" && if [ "$verbose" -eq 1 ]; then printf "%b[+] Created new directory: %s%b\n" "${GREEN}" "${1}" "${RESTORE}"; fi
  else
    if [ "$verbose" -eq 1 ]; then printf "%b[-] Directory already exists: %s%b\n" "${RED}" "${1}" "${RESTORE}"; fi
  fi
}

# Print red error messages and call usage
error_msg() {
  printf "%b[-] Error detected: \n[-] %s%b\n" "${RED}" "$1" "${RESTORE}" 1>&2; usage; 
}

# Test whether the host is pingable and set -Pn accordingly
answers_icmp() {
  # If ping is not returned within a second, then ping scan is disabled with -Pn
  ping_test="$(ping -c 1 -W 1 "$1" 2>/dev/null | grep ttl)"
  if [ -z "${ping_test}" ]; then
    printf "%b[-]%b Ping against %b'%s'%b %bnot possible%b, please make sure your target IP address is correct. Assuming host is up, using -Pn flag for the full scan.%b\n" "${RED}" "${YELLOW}" "${RESTORE}" "$IP" "${YELLOW}" "${RED}" "${YELLOW}" "${RESTORE}"
    ping="-Pn"
  else
    ping=""
  fi
}

running_tool() {
  printf "%b[!] Starting %b%s%b and sending it to the background.%b\n" "${YELLOW}" "${BLUE}" "${1}" "${YELLOW}" "${RESTORE}"
}

finished_tool() {
  # First arg tool name, second arg IP address, third arg directory
  printf "%b[+] Done! %b%s%b for '%b%s%b' finished working on the background.\n\tShortcut: '%bless %s%b'%b\n" "${GREEN}" "${BLUE}" "${1}" "${GREEN}" "${RESTORE}" "${2}" "${GREEN}" "${YELLOW}" "${3}" "${GREEN}" "${RESTORE}"
}

print_phase() {
  printf "\n%b%s%b%s%b" "${BLUE}" "[*] ---------- " "${RESTORE}" "Starting Phase " "${YELLOW}"
  phase="${1}"
  case "${phase}" in
  0)
    printf "%s%b%s" "0" "${RESTORE}" ": running initial checks ";;
  1)
    printf "%s%b%s" "1" "${RESTORE}" ": parsing the CIDR range ";;
  2)
    printf "%s%b%s" "2" "${RESTORE}" ": parsing target or list ";;
  3)
    printf "%s%b%s" "3" "${RESTORE}" ": parsing found ports ";;
  4)
    printf "%s%b%s" "4" "${RESTORE}" ": background tools working ";;
  *)
    error_msg "Development error. There are currently 5 phases in the script ";;
  esac
  printf "%b%s%b\n\n" "${BLUE}" "----------" "${RESTORE}"
}

print_hulk() {
  printf "
%b             _____      %b__________                         
%b______ ____ ___  /_______%b__  ____/_________  ________ ___ 
%b_  __ \` / / / /  __/  __ \\%b_  __/ __  __ \\  / / /_  __ \`__ \\
%b/ /_/ // /_/ // /_ / /_/ /%b  /___ _  / / / /_/ /_  / / / / /
%b\__,_/ \\__,_/ \\__/ \\____/%b/_____/ /_/ /_/\\__,_/ /_/ /_/ /_/ 
%b                    by 0x5ubt13                               \n%b                                            
" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${YELLOW}" "${RED}" "${GREEN}" "${RESTORE}"

}

# ---------- Enumeration Funcions ----------

#Â Quickly scan all TCP ports and save them to $ports
ports_sweep() {
  # First arg target IP, second arg dir
  if [ -n "$dnsServers" ]; then
    # Nmap ports sweep with --dns-servers
    if [ "$verbose" -eq 1 ]; then 
      printf "%b[+]%b -d%b flag detected. Running nmap port sweep with custom DNS servers: %s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${dnsServers}" "${RESTORE}"
    fi
    if [ -n "$top" ]; then
        # Nmap ports sweep with --top-ports=<${top}>
        if [ "$verbose" -eq 1 ]; then 
          printf "%b[+]%b -t%b flag also detected. Running nmap port sweep with --top-ports=%s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${top}" "${RESTORE}"
          printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
        fi
        ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 --top-ports="${top}" "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    else
        if [ "$verbose" -eq 1 ]; then printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"; fi
        ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    fi
  else
    dnsServers="-n"
    if [ -n "$top" ]; then
      # Nmap ports sweep with --top-ports=<${top}>
      if [ "$verbose" -eq 1 ]; then 
        printf "%b[+]%b -t%b flag detected. Running nmap port sweep with --top-ports=%s .%b\n" "${GREEN}" "${YELLOW}" "${GREEN}" "${top}" "${RESTORE}"
        printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"
      fi
      ports=$(nmap --min-rate=2000 "$dnsServers" -sS -p- -T4 --top-ports="${top}" "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
    else
      if [ $slower -eq 1 ]; then
        # Nmap ports sweep
        printf "%b[+] %b-s%b flag detected. Running port sweep with Nmap%b\n" "${GREEN}" "${BLUE}" "${GREEN}" "${RESTORE}"
        if [ "$verbose" -eq 1 ]; then printf "%b[+] Starting nmap SYN port discovery scan against %b'%s'%b...\n" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"; fi
          ports=$(nmap --min-rate=2000 -sS -p- -T5 "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
      else
        rustscan_check=$(locate "/bin/rustscan" -l 1)
        if [ -n "$rustscan_check" ]; then
          # Rustscan ports sweep
          printf "%b[+] %bRustscan%b found, proceeding to sweep ports with Rustscan%b\n" "${GREEN}" "${BLUE}" "${GREEN}" "${RESTORE}"
          if [ "$verbose" -eq 1 ]; then printf "\n%b[!] Starting %bRustscan's%b SYN port discovery scan against %b'%s'%b, please bear with...\n" "${YELLOW}" "${BLUE}" "${YELLOW}" "${RESTORE}" "$1" "${YELLOW}"; fi
          ports="$(rustscan -a "$IP" "$dnsServers" --ulimit 5000 -g | cut -d ' ' -f 3 | sed 's/[^[:alnum:],\t]//g')"
        else
          # Nmap ports sweep
          printf "%b[-] Rustscan not installed, using nmap -p- as a default for port sweeping. Please consider running the installation script.%b" "${YELLOW}" "${RESTORE}"
          if [ "$verbose" -eq 1 ]; then printf "\n${YELLOW}[+] Starting nmap SYN port discovery scan against ${RESTORE}'%s'${YELLOW}...\n" "$1"; fi
          ports=$(nmap --min-rate=2000 -sS -p- -T5 "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")
        fi
      fi
    fi
  fi
  
  # Add and merge to ports an UDP scan.
  # TODO: only currently supporting the scan of SNMP. More to add, dependant on time consume
  ports="${ports}","$(nmap --min-rate=2000 -sU -p161 -T5 --open "$ping" "$1" 2>/dev/null | grep "^[0-9]" | cut -d "/" -f 1 | tr "\n" "," | sed "s/,$//")"

  # Check whether there are ports in the var
  if [ -z "$ports" ]; then
    sweep_result=1
  else
    # Check if we are repeating the scan to discover more ports
    if [ "$again" -eq 1 ] && [ -f "${2}"open_ports.txt ]; then
      if [ "$verbose" -eq 1 ]; then 
        printf "%b[+]%b -a%b flag and previous open ports file detected. Proceeding to compare open ports previouisly detected in %s against a new scan.\n%b" "${GREEN}" "${YELLOW}" "${GREEN}" "${2}open_ports.txt" "${RESTORE}"
      fi
      sweep_result=0
      count1="$(wc -c "${2}"open_ports_repeat.txt | cut -d ' ' -f 1)"
      echo "$ports" > "${2}"open_ports_repeat.txt
      # Compare
      if [[ -n $(diff -q "${2}"open_ports.txt "${2}"open_ports_repeat.txt) ]]; then
        echo "${2}"open_ports.txt >> "${2}"open_ports_repeat.txt
        # Merge both files
        ports="$(< "${2}"open_ports_repeat.txt tr ',' '\n' | sort | uniq | tr '\n' ',' | sed 's/,$//')"
        echo "$ports" > "${2}"open_ports_repeat.txt
        count2="$(wc -c "${2}"open_ports_repeat.txt | cut -d ' ' -f 1)"
        if [ "$count1" -lt "$count2" ]; then
          printf "%b[+] Ports difference detected!\n\tOpen ports in %b'%s'%b: %b%s\n%b[+] Saved as '%b%sopen_ports_repeat.txt%b' in nmap-friendly format.%b\n" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}" "${ports}" "${GREEN}" "${RESTORE}" "${2}" "${GREEN}" "${RESTORE}"
        else
          printf "%b[+] No ports difference detected! Original open ports file left intact.\n\tOpen ports open in %b'%s'%b: %b%s\n%b%b\n" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}" "${ports}" "${GREEN}" "${RESTORE}"
        fi
      else
        printf "%b[+] No ports difference detected! Original open ports file left intact.\n\tOpen ports open in %b'%s'%b: %b%s\n%b%b\n" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}" "${ports}" "${GREEN}" "${RESTORE}"
      fi
    else
      sweep_result=0
      echo "$ports" > "${2}"open_ports.txt
      printf "%b[+] Done! Found open ports on target.\n\tOpen ports in %b'%s'%b: %b%s\n%b[+] Saved as '%b%sopen_ports.txt%b' in nmap-friendly format.%b\n" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}" "${ports}" "${GREEN}" "${RESTORE}" "${2}" "${GREEN}" "${RESTORE}"
    fi
  fi
}

# Proceed with an aggressive scan
aggressive_scan() {
  # First arg IP, second arg directory
  if [ "$verbose" -eq 1 ]; then 
    printf "%b[!] Starting %bmain aggressive vuln nmap scan%b against %b'%s'%b and sending it to the background.\n%b" "${YELLOW}" "${BLUE}" "${YELLOW}" "${RESTORE}" "${1}" "${YELLOW}" "${RESTORE}"
    printf "%b[!] Running '%bnmap -A -v %s --script=vuln -oA %snmap_scan -p%s %s --stats-every 15s &%b'.\n\tShortcut: '%btail -f %snmap_tailable_progress.out%b'%b\n" "${YELLOW}" "${RESTORE}" "${ping}" "${2}" "${ports}" "${1}" "${YELLOW}" "${RESTORE}" "${2}" "${YELLOW}" "${RESTORE}"
  fi
  printf "%b[+] Saving output to %b%snmap_scan.out %bin all formats.%b\n\n" "${GREEN}" "${RESTORE}" "${2}" "${GREEN}" "${RESTORE}"
  
  nmap "${1}" -A -v "$ping" --script=vuln -oA "${2}nmap_scan" -p"$ports" >> "${2}"nmap_tailable_progress.out 2>&1 && \
    xsltproc "${2}nmap_scan.xml" -o "${2}nmap_scan.html" && \
    finished_tool "Main aggressive nmap scan" "${1}" "${2}nmap_scan.nmap" && \
    printf "%b[+] Successfully generated HTML report of the Nmap scan, available at '%b%s%b'.%b\n" "${GREEN}" "${RESTORE}" "${2}nmap_scan.html" "${GREEN}" "${RESTORE}" &
}

wp_enumeration() {
  # Enumeration for WordPress. First arg IP, second arg Port, third arg dir
  wp_version=$(curl -s -X GET http://"${IP}":"${1}" | grep 'wp-content')
  if [ -n "$wp_version" ]; then
    printf "%b[+]%b WordPress%b found.\n" "${GREEN}" "${YELLOW}" "${RESTORE}" 
    running_tool "WPScan"
    wpscan --url http://"${1}":"${2}" -e p,u >> "${3}"wpscan_port_"${2}".out 2>&1 && \
      finished_tool "WPScan" "${1}" "${3}wpscan.out" & 
  fi
}

# Enumerate a whole CIDR range using specific range tools
cidr_enumeration() {
  # First arg target CIDR, second arg dir
  if [ -n "$cidr" ]; then
    # Create dir for output
    cidr_dir="${1}$(echo "$cidr" | sed -e 's/\//_/1')_range_enum/"
    custom_mkdir "$cidr_dir"
    
    # Run range tools
    if [ "$verbose" -eq 1 ]; then printf "%b[+]%b -r%b flag detected. Proceeding to scan CIDR range with dedicated range enumeration tools.\n%b" "${GREEN}" "${YELLOW}" "${GREEN}" "${RESTORE}"; fi
    
    if [ "$verbose" -eq 1 ]; then running_tool "nbtscan-unixwiz"; fi 
    nbtscan-unixwiz -f "$cidr" >> "${cidr_dir}"nbtscan-unixwiz.out 2>&1 && \
      finished_tool "nbtscan-unixwiz" "$cidr" "${cidr_dir}nbtscan-unixwiz.out" &
    
    if [ "$verbose" -eq 1 ]; then running_tool "Responder-RunFinger"; fi
    responder-RunFinger -i "$cidr" >> "${cidr_dir}"runfinger.out 2>&1 && \
      finished_tool "responder-RunFinger" "$cidr" "${cidr_dir}runfinger.out" &
    
    if [ "$verbose" -eq 1 ]; then running_tool "onesixtyone"; fi
    onesixtyone -c "$(locate "SNMP/snmp.txt" -l 1)" "$cidr" -w 100 >> "${cidr_dir}"onesixtyone.out 2>&1 && \
      finished_tool "onesixtyone" "$cidr" "${cidr_dir}onesixtyone.out" &
  else
    printf "%b[!] CIDR range %bNOT%b detected. Remember you can also pass a range in CIDR notation to use enum tools that scan a wide range with '%bautoenum -r <IP address>/<network mask>%b'%b\n" "${YELLOW}" "${RED}" "${YELLOW}" "${BLUE}" "${YELLOW}" "${RESTORE}" 
  fi
}

# Core functionality of this script: iterate through each port and automate launching tools
ports_iterator() {
  # First arg target IP, second arg dir to save output
  dir="${2}"
  
  # Convert comma-separated string to an array of ports
  IFS=',' read -ra PORTS_ARRAY <<< "$ports" ## TODO: convert Here-Strings to POSIX
  
  # Only look once for the wordlists
  if [ "$verbose" -eq 1 ]; then
  dir_list_medium=$(locate "directory-list-2.3-medium.txt" -l 1) && \
    printf "%b[+] Found directory wordlist for web fuzzers.\n\tUsing '%b%s%b'%b\n" "${GREEN}" "${YELLOW}" "${dir_list_medium}" "${GREEN}" "${RESTORE}"
  darkweb_top1000=$(locate "darkweb2017-top1000.txt" -l 1) && \
    printf "%b[+] Found passwords wordlist for password sprayers.\n\tUsing '%b%s%b'%b\n\n" "${GREEN}" "${YELLOW}" "${darkweb_top1000}" "${GREEN}" "${RESTORE}" 
  else
    dir_list_medium=$(locate "directory-list-2.3-medium.txt" -l 1)
    darkweb_top1000=$(locate "darkweb2017-top1000.txt" -l 1)
  fi
  # Iterate over each port in the array
  for port in "${PORTS_ARRAY[@]}"; do ## TODO: convert array to POSIX
    # Use a case statement to perform different actions for each port
    case $port in
    21)
      printf "%b[+] FTP service detected. Running FTP nmap enum scripts.%b\n" "${GREEN}" "${RESTORE}"
      ftp_dir="${dir}ftp/"; custom_mkdir "$ftp_dir"
      
      if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for FTP"; fi
      nmap -sV -n -Pn -p21 "${1}" --script "ftp-* and not brute" -oN "${ftp_dir}ftp_enum.nmap" -v >> "${ftp_dir}"ftp_tailable_nmap_scan.out 2>&1 && \
        finished_tool "Nmap scripts for FTP" "${1}" "${ftp_dir}ftp_enum.nmap" &
      # TODO: add hydra and try to force a list of low-hanging fruit user+pass
      ;;
    22) 
      printf "%b[+] SSH service detected. Running SSH nmap enum scripts.%b\n" "${GREEN}" "${RESTORE}"
      ssh_dir="${dir}ssh/"; custom_mkdir "$ssh_dir"

      if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for SSH"; fi
      nmap -sV -n -Pn -p22 "${1}" --script "ssh* and not brute" -oN "${ssh_dir}ssh_enum.nmap" -v >> "${ssh_dir}"ssh_tailable_nmap_scan.out 2>&1 && \
        finished_tool "Nmap scripts for SSH" "${1}" "${ssh_dir}ssh_enum.nmap" &
      # TODO: add hydra and try to force a list of low-hanging fruit user+pass
      ;;
    25|465|587) 
      # Just run once for now.
      if [ ! -d "${smtp_dir}" ]; then
        printf "%b[+] SMTP service detected. Running SMTP enum tools in port %s%b\n" "${GREEN}" "${port}" "${RESTORE}" 
        smtp_dir="${dir}smtp/"; custom_mkdir "$smtp_dir"

        if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for SMTP"; fi
        nmap -sV -n -Pn -p"$port" --script "smtp-commands,smtp-enum-users,smtp-open-relay" "$1" -v >> "${smtp_dir}"smtp_nmap_scan.out 2>&1 && \
          finished_tool "Nmap scripts for SMTP" "${1}" "${smtp_dir}smtp_nmap_scan.out" &
        fi
      ;;
    53)
      printf "%b[+] SSH service detected. Running SSH nmap enum scripts.%b\n" "${GREEN}" "${RESTORE}"
      dns_dir="${dir}dns/"; custom_mkdir "$dns_dir"

      if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for DNS"; fi
      nmap -n -p53 --script "(default and *dns*) or fcrdns or dns-srv-enum or dns-random-txid or dns-random-srcport" "$1" -v >> "${dns_dir}"dns_nmap_scan.out 2>&1 && \
        finished_tool "Nmap scripts for DNS" "${1}" "${dns_dir}dns_nmap_scan.out" &
      ;;
    80|443|8080)
      # Common Web without TLS
      http_dir="${dir}http/"; custom_mkdir "$http_dir" 
      if [ "$port" -eq 80 ]; then
        printf "%b[+] Running Web enum tools in port 80%b\n" "${GREEN}" "${RESTORE}"
         
        if [ "$verbose" -eq 1 ]; then running_tool "Nikto on port 80"; fi
        nikto -host "${1}" >> "${http_dir}"nikto_tailable_80.out 2>&1 && \
          finished_tool "Nikto" "${1}" "${http_dir}nikto_80.out" &
        
        # ffuf killswitch activated after 5 mins of running to save energy and avoid dangling processes consuming CPU
        if [ -n "$dir_list_medium" ]; then
          if [ "$verbose" -eq 1 ]; then running_tool "ffuf on port 80"; fi
          ffuf -u http://"${1}":80/FUZZ -w "$dir_list_medium":FUZZ -recursion -recursion-depth 1 -e .php,.asp,.aspx -t 20 -v -maxtime 300 -maxtime-job 300 >> "${http_dir}"ffuf_80_tailable.out 2>&1 && \
            finished_tool "ffuf" "${1}" "${http_dir}ffuf_tailable_80.out" &
        else
          printf "%b[-] Error: %bmedium directory wordlist not found. Aborting web fuzzing on port 80." "${RED}" "${RESTORE}"
        fi
        wp_enumeration "${1}" "80" "${http_dir}"
      elif [ "$port" -eq 443 ]; then
        # Common Web 
        printf "%b[+] Running Web enum tools in port 443%b\n" "${GREEN}" "${RESTORE}"
  
        if [ "$verbose" -eq 1 ]; then running_tool "Nikto"; fi
        nikto -host "${1}" >> "${http_dir}"nikto_tailable_443.out 2>&1 && \
          finished_tool "Nikto on port 443" "${1}" "${http_dir}nikto_tailable_443.out" &
  
        # ffuf killswitch activated after 5 mins of running to save energy and avoid dangling processes consuming CPU
        if [ -z "$dir_list_medium" ]; then
          if [ "$verbose" -eq 1 ]; then running_tool "ffuf on port 443"; fi
          ffuf -u https://"${1}":443/FUZZ -w "$dir_list_medium":FUZZ -recursion -recursion-depth 1 -e .php,.asp,.aspx -t 20 -v -maxtime 300 -maxtime-job 300 >> "${http_dir}"ffuf_443_tailable.out 2>&1 && \
            finished_tool "ffuf on port 443" "${1}" "${http_dir}ffuf_tailable_443.out" &
        else
          printf "%b[-] Error: %bmedium directory wordlist not found. Aborting web fuzzing on port 443." "${RED}" "${RESTORE}"
        fi
        wp_enumeration "${1}" "443" "${http_dir}"
      else
        # Try and enumerate port 8080
        printf "%b[+] Running Web enum tools in port 8080%b\n" "${GREEN}" "${RESTORE}"
        wp_enumeration "${1}" "8080" "${http_dir}" 
        
        tomcat_version=$(curl -s -X GET http://"${IP}":8080/docs/ | grep -i 'Tomcat')
        if [ -n "$tomcat_version" ]; then
          printf "%b[+] Web service Tomcat detected. Running Tomcat enum tools%b\n" "${GREEN}" "${RESTORE}"
    
          if [ -n "$dir_list_medium" ]; then
            if [ "$verbose" -eq 1 ]; then running_tool "gobuster"; fi
            gobuster -z -q dir -e -u "${1}":8080 -w "$dir_list_medium" >> "${http_dir}"gobuster_tomcat.out 2>&1 && \
              finished_tool "gobuster on port 8080" "${1}" "${http_dir}gobuster_tomcat.out" &
          else
          printf "%b[-] Error: %bmedium directory wordlist not found. Aborting web fuzzing on port 8080." "${RED}" "${RESTORE}"
          fi
          if [ -n "$darkweb_top1000" ]; then
            if [ "$verbose" -eq 1 ]; then running_tool "hydra"; fi
            hydra -L users.txt -P "$darkweb_top1000" -f "${1}" http-get /manager/html >> "${http_dir}"hydra_tailable.out 2>&1 && \
              finished_tool "Hydra" "${1}" "${http_dir}hydra_tailable.out" &
          else
          printf "%b[-] Error: %bdarkweb_top1000 wordlist not found. Aborting bruteforcing with hydra on port 8080." "${RED}" "${RESTORE}"
          fi
        fi
      fi 
      ;;
    110|143|993|995)
      if [ ! -d "${dir}imap_pop3/" ]; then
        printf "%b[+] IMAP / POP3 service detected. Running IMAP / POP3 enum scripts.%b\n" "${GREEN}" "${RESTORE}"
        imap_pop3_dir="${dir}imap_pop3/"; custom_mkdir "$imap_pop3_dir" 

        if [ "$verbose" -eq 1 ]; then running_tool "Nmap for IMAP / POP3"; fi
        nmap "${1}" -sVC -p110,143,993,995 >> "${imap_pop3_dir}imap_pop3_nmap_scan.out" 2>&1 && \
          finished_tool "Nmap for IMAP / POP3" "${1}" "${imap_pop3_dir}imap_pop3_nmap_scan.out" &
        
        if [ "$verbose" -eq 1 ]; then running_tool "OpenSSL for IMAP"; fi
        openssl s_client -connect "${1}":imaps > "${imap_pop3_dir}openssl_imap.out" 2>&1 && \
          finished_tool "OpenSSL for IMAP" "${1}" "${imap_pop3_dir}openssl_imap.out" &

        # TODO: implement banner grabbing
        # nc -nv "${1}" 110 > "${imap_pop3_dir}110_banner_grab.out" 2>&1 || \
        #   finished_tool "OpenSSL for IMAP" "${1}" "${imap_pop3_dir}110_banner_grab.out" &  
      fi
      ;;
    111)
      if [ ! -d "${dir}"rpc/ ]; then
        printf "%b[+] RPC service detected. Running RPC nmap enum scripts.%b\n" "${GREEN}" "${RESTORE}"
        rpc_dir="${dir}rpc/"; custom_mkdir "$rpc_dir"
  
        if [ "$verbose" -eq 1 ]; then running_tool "Nmap for RPC on UDP"; fi
        nmap -n -Pn -sVC -p 111 -sU "${1}" >> "${rpc_dir}rpc_udp_tailable_nmap_scan" 2>&1 && \
          finished_tool "Nmap for RPC on UDP" "${1}" "${rpc_dir}rpc_udp_nmap_scan.nmap" &
      fi
      ;;
    137|138|139|445)
      # Run only once
      if [ ! -d "${dir}nb_smb" ]; then
        printf "%b[+] NetBIOS/SMB detected. Running NB/SMB enum tools.%b\n" "${GREEN}" "${RESTORE}"
        nb_smb_dir="${dir}nb_smb/"; custom_mkdir "$nb_smb_dir"
        
        if [ "$verbose" -eq 1 ]; then running_tool "CrackMapExec"; fi
        crackmapexec smb "${1}" --shares -u '' -p '' --shares --sessions --disks --loggedon-users --users --groups --computers --local-groups --pass-pol --rid-brute >> "${nb_smb_dir}"cme_anon.out 2>&1 && \
          finished_tool "CrackMapExec" "${1}" "${nb_smb_dir}cme_anon.out" &
        
        if [ "$verbose" -eq 1 ]; then running_tool "SMBMap"; fi
        smbmap -H "${1}" >> "${nb_smb_dir}smbmap_anon.out" 2>&1 && \
          finished_tool "SMBMap" "${1}" "${nb_smb_dir}smbmap_anon.out" &
  
        if [ "$verbose" -eq 1 ]; then running_tool "NBLookup"; fi
        nmblookup -A "${1}" >> "${nb_smb_dir}nmblookup.out" 2>&1 && \
          finished_tool "NMBLookup" "${1}" "${nb_smb_dir}nmblookup.out" &
    
        if [ "$verbose" -eq 1 ]; then running_tool "enum4linux"; fi
        enum4linux -u '' -p '' "${1}" >> "${nb_smb_dir}enum4linux_anon.out" 2>&1 && \
          finished_tool "enum4linux" "${1}" "${nb_smb_dir}enum4linux_anon.out" & 

        if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for NB/SMB"; fi
        nmap -Pn -sUV -p137 -n -sV --script "nbstat.nse" "${1}" -v >> "${nb_smb_dir}nb_udp_tailable_nmap_scan.out" 2>&1 &&
          finished_tool "Nmap scripts for NetBios" "${1}" "${nb_smb_dir}nb_enum.nmap" &
        nmap -Pn -p139,445 -n -sV --script "smb* and not brute" "${1}" -v >> "${nb_smb_dir}smb_tailable_nmap_scan.out" 2>&1 && \
          finished_tool "Nmap scripts for SMB" "${1}" "${nb_smb_dir}smb_enum.nmap" &
      fi
      ;;
    161)
      # TODO: Hold on all SNMP enumeration until onesixtyone has finished bruteforcing community strings, then launch the tools in a loop against all the found CS
      printf "%b[+] SNMP detected. Running SNMP enum tools.%b\n" "${GREEN}" "${RESTORE}"
      snmp_dir="${dir}snmp/"; custom_mkdir "$snmp_dir"
      
      # Same/very similar output detected from v1 and v2c, commenting out v1 for now 
      #if [ "$verbose" -eq 1 ]; then running_tool "SNMPWalk v1"; fi
      #snmpwalk -v1 -c public "${1}" >> "${snmp_dir}snmpwalk_v1_public.out" 2>&1 && \
      #  grep "= STRING:" "${snmp_dir}snmpwalk_v2c_public.out" > "${snmp_dir}snmpwalk_v2c_public_strings.out" && \
      #  finished_tool "SNMPWalk v1" "${1}" "${snmp_dir}snmpwalk_v1_public.out" &

      if [ "$verbose" -eq 1 ]; then running_tool "SNMPWalk v2c"; fi
      snmpwalk -v2c -c public "${1}" >> "${snmp_dir}snmpwalk_v2c_public.out" 2>&1 && \
        grep "= STRING:" "${snmp_dir}snmpwalk_v2c_public.out" > "${snmp_dir}snmpwalk_v2c_public_strings.out" && \
        finished_tool "SNMPWalk v2c" "${1}" "${snmp_dir}snmpwalk_v2c_public_strings.out" &

      if [ "$verbose" -eq 1 ]; then running_tool "OneSixtyOne"; fi
      onesixtyone -c "$(locate SNMP/snmp.txt -l 1)" "${1}" >> "${snmp_dir}onesixtyone.out" 2>&1 && \
        finished_tool "enum4linux" "${1}" "${snmp_dir}onesixtyone.out" &
      
      if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for SNMP"; fi
      nmap -sVU -p161 -n --script "snmp* and not snmp-brute" "${1}" >> "${snmp_dir}snmp_nmap_scan.out" 2>&1 && \
        finished_tool "Nmap scripts for SNMP" "${1}" "${snmp_dir}snmp_nmap_scan.out" &

      if [ "$verbose" -eq 1 ]; then running_tool "Braa"; fi
      braa "public@${1}:.1.3.6.*" >> "${snmp_dir}braa.out" 2>&1 && \
        finished_tool "braa" "${1}" "${snmp_dir}braa.out" &
      ;;
    389|636|3268|3269)
      # Run only once
      if [ ! -d "${dir}ldap/" ]; then
        printf "%b[+] Running LDAP enum tools in port %s%b\n" "${GREEN}" "${port}" "${RESTORE}" 
        
        ldap_dir="${dir}ldap/"; custom_mkdir "$ldap_dir"
        if [ "$verbose" -eq 1 ]; then running_tool "ldapsearch (null credentials attack)"; fi
        ldapsearch -x -H ldap://"${1}" -D '' -w '' -b "DC=<1_SUBDOMAIN>,DC=<TLD>" >> "${ldap_dir}ldapsearch.out" 2>&1 && \
          finished_tool "ldapsearch" "${1}" "${dir}ldapsearch.out" &
        
        if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for LDAP"; fi
        nmap -Pn -p"$port" -n -sV --script "ldap* and not brute" "${1}" -v >> "${ldap_dir}ldap_tailable_nmap_scan.out" 2>&1 && \
          finished_tool "Nmap scripts for LDAP" "${1}" "${dir}ldap_enum.nmap" &
      fi
      ;;
    2049)
      printf "%b[+] NFS service detected. Running NFS nmap enum scripts.%b\n" "${GREEN}" "${RESTORE}"

      if [ "$verbose" -eq 1 ]; then running_tool "Nmap scripts for NFS"; fi
      nmap -sV -n -Pn -p2049,111 "${1}" --script "nfs-ls,nfs-showmount,nfs-statfs" -oN "${dir}ftp_enum.nmap" -v >> "${dir}"ftp_tailable_nmap_scan.out 2>&1 && \
        finished_tool "Nmap scripts for NFS" "${1}" "${dir}ftp_enum.nmap" &
      
      if [ "$verbose" -eq 1 ]; then running_tool "Showmount + mount"; fi
      showmount -e "${1}" >> "${dir}"showmount.out 2>&1 && \
        mkdir "${dir}"mounted_NFS_contents/ && \
        mount -t nfs "${1}":/ "${dir}"mounted_NFS_contents/ - && \
        tree "${dir}"mounted_NFS_contents/ >> "${dir}tree_nfs_directory.out" 2>&1 && \
        finished_tool "Showmount + mount" "${1}" "${dir}showmount.out && cat ${dir}tree_nfs_directory.out" &
      ;;
  # 512)
  #  hydra
  #  ;;
  # 513)
  #  hydra  
  #  ;;
  # 514)
  #  hydra
  #  ;;
  # 554|8554)
  #  hydra
  #  ;;
  # 1521)
  #  tool x
  #  ;;
  # To add:
  #   - SQL
  #   - rsync (873)
  #   - rtsp -> hydra (554, 8554)
    *)
      # Hiding message if verbose flag is disabled, since this can be very noisy for high RPC ports
      if [ "$verbose" -eq 1 ]; then 
        printf "%b[-]%b Port %b%s%b detected, but I don't know how to handle it. Please check the %bmain Nmap%b scan.\n" "${RED}" "${RESTORE}" "${YELLOW}" "$port" "${RESTORE}" "${BLUE}" "${RESTORE}"
      fi
      ;;
    esac
  done
  printf "%b[+] Done! All well-known ports included in the script successfully parsed for %b%s%b.\n%b" "${GREEN}" "${RESTORE}" "${1}" "${GREEN}" "${RESTORE}"
}


# ---------- Let the fun begin! MAIN Function ----------

main() {
  if [ "$verbose" -eq 1 ]; then print_phase 1; fi
  # Perform CIDR enumeration first, check if CIDR argument was passed
  cidr_enumeration "${DIR}"
  
  if [ "$verbose" -eq 1 ]; then print_phase 2; fi
  # Check whether input is a single or multiple target and loop accordingly
  if [[ ! -f "$IP" ]]; then 
    # ---------- Single target ----------
    dir="${DIR}${IP}/"; custom_mkdir "${dir}"
    printf "%b[+] Using '%b%s%b' as single target IP and '%b%s%b' for all the tools output%b\n" "${GREEN}" "${RESTORE}" "${IP}" "${GREEN}" "${RESTORE}" "${dir}" "${GREEN}" "${RESTORE}"

    # Checking whether the target is reachable via ping
    answers_icmp "${IP}"

    # Do port discovery scan
    ports_sweep "${IP}" "${dir}"
    
    # Abort tests if no ports were found open
    if [ "$sweep_result" -eq 1 ]; then 
      printf "%b[-] No open ports were found in %s, aborting all scans\n%b" "${RED}" "${IP}" "${RESTORE}"
      exit 1
    fi

    # If still alive, proceed with full nmap scan and ports iterator
    if [ "$verbose" -eq 1 ]; then print_phase 3; fi
    aggressive_scan "${IP}" "${dir}"

    # Iterate over each port in the array
    ports_iterator "${IP}" "${dir}" ## TODO: convert ports_iterator to POSIX
  else # ---------- Multi-target: ----------
    printf "%b[+] Using %b'%s'%b as targets file\n" "${GREEN}" "${RESTORE}" "${IP}" "${GREEN}" 
    printf "[+] Successfully identified %b'%s'%b targets in the file\n" "${RESTORE}" "${list_total_lines}" "${GREEN}"

    # loop through the targets and assign vars accordingly
    line=1
    if [ "$verbose" -eq 1 ]; then print_phase 3; fi
    while [ "$line" -le "$list_total_lines" ]; do
      target=$(sed "${line}q;d" "$IP" 2>/dev/null)
      # target_number="_target_${line}"
      dir="$(pwd)/nmap/${target}/"
  
      # Colouring red to catch mkdir's File exists error
      printf "%b" "${RED}"; mkdir "${dir}"; printf "%b" "${RESTORE}"
      
      # More info to console
      printf "%b[+] Attacking target '%b%s%b/%b%s%b': '%b%s%b'. " "${GREEN}" "${RESTORE}" "${line}" "${GREEN}" "${RESTORE}" "$list_total_lines" "${GREEN}" "${RESTORE}" "$target" "${GREEN}"
      printf "%b[+] Using '%b%s%b' for all this target's tools output%b\n" "${GREEN}" "${RESTORE}" "${dir}" "${GREEN}" "${RESTORE}" 
  
      # TCP Scans
      # Checking whether the target is reachable via ping
      answers_icmp "$target"
  
      # Do port discovery scan
      ports_sweep "$target"
      
      # Abort tests if no ports were found open
      if [ "$sweep_result" -eq 1 ]; then 
        printf "%b[-] No open ports were found in %s, aborting all scans for this target\n%b" "${RED}" "${target}" "${RESTORE}"
      else
        # Proceed with nmap scan and ports iterator
        aggressive_scan "$target"

        # Iterate over each port in the array
        ports_iterator "$target" ## TODO: convert ports_iterator to POSIX
      fi

      # Loop counter
      line=$(( line + 1 ))
    done
  fi
}


# ---------- Script checks, ensuring everything is ready to run ----------

# Check 0: Launch fancy (Bruce) Banner! 
if [ "$verbose" -eq 1 ]; then print_hulk; print_phase 0; fi # Ba-dum-tss!

# Check 1: help flag passed?
if [ -n "$do_help" ]; then
  if [ "$verbose" -eq 1 ]; then printf "%b[*] Help flag detected. Aborting other cheks and printing usage.\n%b" "${BLUE}" "${RESTORE}"; fi
  usage
fi

# Check 2: Ensure there is a target
if [[ -n "$ip" ]]; then
  IP="$ip"
else
  error_msg "You must provide an IP address or targets file to start the attack"
fi

# Check 3: Determine whether it is a single target or multi-target
if [[ ! -f "$IP" ]]; then # Single target
  # Ensure $IP is either an IP or a URL
  if ! expr "${IP}" : "\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)" >/dev/null && \
     ! expr "${IP}" : "\(\([[:alnum:]-]\{1,63\}\.\)*[[:alpha:]]\{2,6\}\)" >/dev/null; then
      error_msg "Invalid IP or URL!"
  fi
else
  # Multi-target, check how many targets are there
  list_total_lines=$(wc -l "$IP" | awk '{ print $1 }')
fi

# Check 4: Ensure base output directory is correctly set and exists
##Â TODO: create option to set custom directory if launched autonomously outside Docker
if test "$(pwd)" = "/"; then
  DIR="/autoEnum_output/"
else
  DIR="$(pwd)/autoEnum_output/"
fi

custom_mkdir "${DIR}"

# Check 5: locate exists in the system
updatedb_check=$(which updatedb)
# TODO: Remove this requisite for the containerised version of the script
if [ -z "$updatedb_check" ]; then
  error_msg "AutoEnum needs \"locate\" to be installed. Please see or run \"install_requisites.sh\", or manually install \"locate\""
fi

printf "%b[+] Using '%b%s%b' as base directory where to save the output files%b\n" "${GREEN}" "${RESTORE}" "${DIR}" "${GREEN}" "${RESTORE}"


# ---------- Preliminary checks completed. Starting engines! Calling main function ----------

# Let there be (~l~i~g~h~t~) enumeration.
main

# ---------- Finish script and wait for tools to finish on the background ----------

# Finished. Getting timing score
if [ "$verbose" -eq 1 ]; then print_phase 4; fi
END="$(date +%s)"
runtime="$((END - START))"
printf "%b[*] All done! It only took '%b%s seconds%b' to run autoEnum based on your settings!! Please allow your tools some time to finish.%b" "${BLUE}" "${GREEN}" "$runtime" "${BLUE}" "${RESTORE}"
printf "\n\n%b[*] %s" "${BLUE}" "This tool is still in its early days. Do you have any feedback? Please feel free to reach out: https://github.com/0x5ubt13"